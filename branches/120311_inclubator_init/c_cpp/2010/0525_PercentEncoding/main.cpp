#include "PercentEncoding.h"
#include <Windows.h>
#include <iostream>

const char* TestString2 =
	"Network Working Group TBerners-LeeRequest for Comments: 3986 W3C/MITSTD: 66 RFieldingUpdates: 1738 Day SoftwareObsoletes: 2732, 2396, 1808 LMasinterCategory: Standards Track Adobe Systems January 2005 Uniform Resource Identifier (URI): Generic SyntaxStatus of This Memo This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol Distribution of this memo is unlimited.Copyright Notice Copyright (C) The Internet Society (2005).Abstract A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.Berners-Lee, et al Standards Track [Page 1]RFC 3986 URI Generic Syntax January 2005Table of Contents 1 Introduction 4 1.1 Overview of URIs 4 1.1.1 Generic Syntax 6 1.1.2 Examples 7 1.1.3 URI, URL, and URN 7 1.2 Design Considerations 8 1.2.1 Transcription 8 1.2.2 Separating Identification from Interaction 9 1.2.3 Hierarchical Identifiers 10 1.3 Syntax Notation 11 2 Characters 11 2.1 Percent-Encoding 12 2.2 Reserved Characters 12 2.3 Unreserved Characters 13 2.4 When to Encode or Decode 14 2.5 Identifying Data 14 3 Syntax Components 16 3.1 Scheme 17 3.2 Authority 17 3.2.1 User Information 18 3.2.2 Host 18 3.2.3 Port 22 3.3 Path 22 3.4 Query 23 3.5 Fragment 24 4 Usage 25 4.1 URI Reference 25 4.2 Relative Reference 26 4.3 Absolute URI 27 4.4 Same-Document Reference 27 4.5 Suffix Reference 27 5 Reference Resolution 28 5.1 Establishing a Base URI 28 5.1.1 Base URI Embedded in Content 29 5.1.2 Base URI from the Encapsulating Entity 29 5.1.3 Base URI from the Retrieval URI 30 5.1.4 Default Base URI 30 5.2 Relative Resolution 30 5.2.1 Pre-parse the Base URI 31 5.2.2 Transform References 31 5.2.3 Merge Paths 32 5.2.4 Remove Dot Segments 33 5.3 Component Recomposition 35 5.4 Reference Resolution Examples 35 5.4.1 Normal Examples 36 5.4.2 Abnormal Examples 36Berners-Lee, et al Standards Track [Page 2]RFC 3986 URI Generic Syntax January 2005 6 Normalization and Comparison 38 6.1 Equivalence 38 6.2 Comparison Ladder 39 6.2.1 Simple String Comparison 39 6.2.2 Syntax-Based Normalization 40 6.2.3 Scheme-Based Normalization 41 6.2.4 Protocol-Based Normalization 42 7 Security Considerations 43 7.1 Reliability and Consistency 43 7.2 Malicious Construction 43 7.3 Back-End Transcoding 44 7.4 Rare IP Address Formats 45 7.5 Sensitive Information 45 7.6 Semantic Attacks 45 8 IANA Considerations 46 9 Acknowledgements 46 10References 46 10.1Normative References 46 10.2Informative References 47 A Collected ABNF for URI 49 B Parsing a URI Reference with a Regular Expression 50 C Delimiting a URI in Context 51 D Changes from RFC 2396 53 D.1 Additions 53 D.2 Modifications 53 Index 56 Authors' Addresses 60 Full Copyright Statement 61Berners-Lee, et al Standards Track [Page 3]RFC 3986 URI Generic Syntax January 20051 Introduction A Uniform Resource Identifier (URI) provides a simple and extensible means for identifying a resource This specification of URI syntax and semantics is derived from concepts introduced by the World Wide Web global information initiative, whose use of these identifiers dates from 1990 and is described in \"Universal Resource Identifiers in WWW\" [RFC1630] The syntax is designed to meet the recommendations laid out in \"Functional Recommendations for Internet Resource Locators\" [RFC1736] and \"Functional Requirements for Uniform Resource Names\" [RFC1737]. This document obsoletes [RFC2396], which merged \"Uniform Resource Locators\" [RFC1738] and \"Relative Uniform Resource Locators\" [RFC1808] in order to define a single, generic syntax for all URIs. It obsoletes [RFC2732], which introduced syntax for an IPv6 address. It excludes portions of RFC 1738 that defined the specific syntax of individual URI schemes; those portions will be updated as separate documents The process for registration of new URI schemes is defined separately by [BCP35] Advice for designers of new URI schemes can be found in [RFC2718] All significant changes from RFC 2396 are noted in Appendix D. This specification uses the terms \"character\" and \"coded character set\" in accordance with the definitions provided in [BCP19], and \"character encoding\" in place of what [BCP19] refers to as a \"charset\".1.1 Overview of URIs URIs are characterized as follows: Uniform Uniformity provides several benefits It allows different types of resource identifiers to be used in the same context, even when the mechanisms used to access those resources may differ It allows uniform semantic interpretation of common syntactic conventions across different types of resource identifiers It allows introduction of new types of resource identifiers without interfering with the way that existing identifiers are used It allows the identifiers to be reused in many different contexts, thus permitting new applications or protocols to leverage a pre- existing, large, and widely used set of resource identifiers.Berners-Lee, et al Standards Track [Page 4]RFC 3986 URI Generic Syntax January 2005 Resource This specification does not limit the scope of what might be a resource; rather, the term \"resource\" is used in a general sense for whatever might be identified by a URI Familiar examples include an electronic document, an image, a source of information with a consistent purpose (e.g., \"today's weather report for Los Angeles\"), a service (e.g., an HTTP-to-SMS gateway), and a collection of other resources A resource is not necessarily accessible via the Internet; e.g., human beings, corporations, and bound books in a library can also be resources Likewise, abstract concepts can be resources, such as the operators and operands of a mathematical equation, the types of a relationship (e.g., \"parent\" or \"employee\"), or numeric values (e.g., zero, one, and infinity). Identifier An identifier embodies the information required to distinguish what is being identified from all other things within its scope of identification Our use of the terms \"identify\" and \"identifying\" refer to this purpose of distinguishing one resource from all other resources, regardless of how that purpose is accomplished (e.g., by name, address, or context) These terms should not be mistaken as an assumption that an identifier defines or embodies the identity of what is referenced, though that may be the case for some identifiers Nor should it be assumed that a system using URIs will access the resource identified: in many cases, URIs are used to denote resources without any intention that they be accessed Likewise, the \"one\" resource identified might not be singular in nature (e.g., a resource might be a named set or a mapping that varies over time). A URI is an identifier consisting of a sequence of characters matching the syntax rule named <URI> in Section 3 It enables uniform identification of resources via a separately defined extensible set of naming schemes (Section 3.1) How that identification is accomplished, assigned, or enabled is delegated to each scheme specification. This specification does not place any limits on the nature of a resource, the reasons why an application might seek to refer to a resource, or the kinds of systems that might use URIs for the sake of identifying resources This specification does not require that a URI persists in identifying the same resource over time, though that is a common goal of all URI schemes Nevertheless, nothing in thisBerners-Lee, et al Standards Track [Page 5]RFC 3986 URI Generic Syntax January 2005 specification prevents an application from limiting itself to particular types of resources, or to a subset of URIs that maintains characteristics desired by that application. URIs have a global scope and are interpreted consistently regardless of context, though the result of that interpretation may be in relation to the end-user's context For example, \"http://localhost/\" has the same interpretation for every user of that reference, even though the network interface corresponding to \"localhost\" may be different for each end-user: interpretation is independent of access. However, an action made on the basis of that reference will take place in relation to the end-user's context, which implies that an action intended to refer to a globally unique thing must use a URI that distinguishes that resource from all other things URIs that identify in relation to the end-user's local context should only be used when the context itself is a defining aspect of the resource, such as when an on-line help manual refers to a file on the end- user's file system (e.g., \"file:///etc/hosts\").1.1.1 Generic Syntax Each URI begins with a scheme name, as defined in Section 3.1, that refers to a specification for assigning identifiers within that scheme As such, the URI syntax is a federated and extensible naming system wherein each scheme's specification may further restrict the syntax and semantics of identifiers using that scheme. This specification defines those elements of the URI syntax that are required of all URI schemes or are common to many URI schemes It thus defines the syntax and semantics needed to implement a scheme- independent parsing mechanism for URI references, by which the scheme-dependent handling of a URI can be postponed until the scheme-dependent semantics are needed Likewise, protocols and data formats that make use of URI references can refer to this specification as a definition for the range of syntax allowed for all URIs, including those schemes that have yet to be defined This decouples the evolution of identification schemes from the evolution of protocols, data formats, and implementations that make use of URIs. A parser of the generic URI syntax can parse any URI reference into its major components Once the scheme is determined, further scheme-specific parsing can be performed on the components In other words, the URI generic syntax is a superset of the syntax of all URI schemes.Berners-Lee, et al Standards Track [Page 6]RFC 3986 URI Generic Syntax January 20051.1.2 Examples The following example URIs illustrate several URI schemes and variations in their common syntax components: ftp://ftp.is.co.za/rfc/rfc1808.txt http://www.ietf.org/rfc/rfc2396.txt ldap://[2001:db8::7]/c=GB?objectClass?one mailto:John.Doe@example.com news:comp.infosystems.www.servers.unix tel:+1-816-555-1212 telnet://192.0.2.16:80/ urn:oasis:names:specification:docbook:dtd:xml:4.1.21.1.3 URI, URL, and URN A URI can be further classified as a locator, a name, or both The term \"Uniform Resource Locator\" (URL) refers to the subset of URIs that, in addition to identifying a resource, provide a means of locating the resource by describing its primary access mechanism (e.g., its network \"location\") The term \"Uniform Resource Name\" (URN) has been used historically to refer to both URIs under the \"urn\" scheme [RFC2141], which are required to remain globally unique and persistent even when the resource ceases to exist or becomes unavailable, and to any other URI with the properties of a name. An individual scheme does not have to be classified as being just one of \"name\" or \"locator\" Instances of URIs from any given scheme may have the characteristics of names or locators or both, often depending on the persistence and care in the assignment of identifiers by the naming authority, rather than on any quality of the scheme Future specifications and related documentation should use the general term \"URI\" rather than the more restrictive terms \"URL\" and \"URN\" [RFC3305].Berners-Lee, et al Standards Track [Page 7]RFC 3986 URI Generic Syntax January 20051.2 Design Considerations1.2.1 Transcription The URI syntax has been designed with global transcription as one of its main considerations A URI is a sequence of characters from a very limited set: the letters of the basic Latin alphabet, digits, and a few special characters A URI may be represented in a variety of ways; e.g., ink on paper, pixels on a screen, or a sequence of character encoding octets The interpretation of a URI depends only on the characters used and not on how those characters are represented in a network protocol. The goal of transcription can be described by a simple scenario. Imagine two colleagues, Sam and Kim, sitting in a pub at an international conference and exchanging research ideas Sam asks Kim for a location to get more information, so Kim writes the URI for the research site on a napkin Upon returning home, Sam takes out the napkin and types the URI into a computer, which then retrieves the information to which Kim referred. There are several design considerations revealed by the scenario: o A URI is a sequence of characters that is not always represented as a sequence of octets. o A URI might be transcribed from a non-network source and thus should consist of characters that are most likely able to be entered into a computer, within the constraints imposed by keyboards (and related input devices) across languages and locales. o A URI often has to be remembered by people, and it is easier for people to remember a URI when it consists of meaningful or familiar components. These design considerations are not always in alignment For example, it is often the case that the most meaningful name for a URI component would require characters that cannot be typed into some systems The ability to transcribe a resource identifier from one medium to another has been considered more important than having a URI consist of the most meaningful of components. In local or regional contexts and with improving technology, users might benefit from being able to use a wider range of characters; such use is not defined by this specification Percent-encoded octets (Section 2.1) may be used within a URI to represent characters outside the range of the US-ASCII coded character set if thisBerners-Lee, et al Standards Track [Page 8]RFC 3986 URI Generic Syntax January 2005 representation is allowed by the scheme or by the protocol element in which the URI is referenced Such a definition should specify the character encoding used to map those characters to octets prior to being percent-encoded for the URI.1.2.2 Separating Identification from Interaction A common misunderstanding of URIs is that they are only used to refer to accessible resources The URI itself only provides identification; access to the resource is neither guaranteed nor implied by the presence of a URI Instead, any operation associated with a URI reference is defined by the protocol element, data format attribute, or natural language text in which it appears. Given a URI, a system may attempt to perform a variety of operations on the resource, as might be characterized by words such as \"access\", \"update\", \"replace\", or \"find attributes\" Such operations are defined by the protocols that make use of URIs, not by this specification However, we do use a few general terms for describing common operations on URIs URI \"resolution\" is the process of determining an access mechanism and the appropriate parameters necessary to dereference a URI; this resolution may require several iterations To use that access mechanism to perform an action on the URI's resource is to \"dereference\" the URI. When URIs are used within information retrieval systems to identify sources of information, the most common form of URI dereference is \"retrieval\": making use of a URI in order to retrieve a representation of its associated resource A";
const char* TestString3 =
	" 통합검색 · 마을서비스란? · 포럼마을 · 일반마을 · 테마마을 · 마을랭킹 · 활동왕 · 덱스퍼트란? · TECBOX · PRSBOX · 이용안내 · DEXT제품군 · 내부통제시스템 · 솔루션베이 · S/W & ESD 컴포넌트 · 아이티트랜드 · 제휴문의 · Event Mall · ImDev-리쿠르팅 · ImDev-아웃소싱 · 닷넷컨설팅 · IT 과정 · DOT Zone · LiveSeminar · LiveConference Architecture 촌장 손영수 주민 864 since 2006-12-28 우리마을 공지사항 질문&답변 강좌&팁 자유게시판 자료실 앨범 개인게시판 [마을 게시판] Architecture&Design Pattern Testing & QA Development Process SOA & SaaS Eva네 컬럼 진행중인 스터디 Eva 네 Jornadan 네 랑데브 게시판 칼럼 게시판 개발자 고충상담 Dev Talk 자유토론방 벼룩시장 재나미 우스개 IT이야기 노땅엔지니어의 노트 고객지원 게시판 마이 데브피아 나의 e-Money 내역 활동왕 My Page 스크랩한 게시글보기 쪽지관리 주소록관리 일정관리 자유게시판 [A&D Games] 추연우씨가 말씀하신 if 문 예제를 짜 봤습니다... 2006-06-05 오후 6:22:47 박일 (ParkPD) 번호: 1125 / 읽음:380 추연우씨가 스터디 중에 한 얘기는..'최적화를 위해서는 가장 자주, 가장 먼저 걸리는 조건문이 if 나 case 의 맨 먼저 오게 해야한다.' 라는 거였습니다.그래서 다음과 같은 예제문을 만들어 보았지요... 정말 if 문이 가장 먼저 걸리는게 속도 면에서 중요하겠더군요.요즘이야 최적화에 너무 신경 쓸 필요가 없다지만가장 자주 발생할만한 부분을 if 문에 걸어두는게 의미론적으로도 적합한 듯 하니까 (Code Complete 2ed)버릇을 들여두면 좋겠더군요. 추연우씨. 소중한 정보 감사요. if 문 #// 예제 1int Test() { DWORD start = GetTickCount(); int test = 0; int i = 0;		// 여기를 바꾸면서 테스트 for (int k = 0; k < 1000000; ++k) { if (i == 0) { test += 3; } else if (i == 1) {			test += 2;		} else {			test += 5;		}	}	return GetTickCount() - start; }이 경우 디버그 버전에서 로 하면 i = 0 일때 281, i = 1 일때 350, i = 2 일 때 370 정도가 나온다.그런데!!! 릴리즈에서는 항상 0 이 나온다. 왜일까?정답! --> test 값은 컴파일 타임에서 결정되어 있다.i 는 항상 0 이고 test 도 초기값이 항상 0 이기 때문에 Test() 가 호출될 때 test 의 결과값은 언제나 3000000 이다.그래서 컴파일러는 test = 3000000 로 아예 정해놓고, 따로 for loop 에는 asm 코드를 만들지 않는다.그래서 다시 코드를 짰다.// 예제 2int Test(int i) {	// 이제 i 를 파라메타로 받는다. DWORD start = GetTickCount(); int test = 0; for (int k = 0; k < 1000000; ++k) { if (i == 0) { test += 3; } else if (i == 1) {			test += 2;		} else {			test += 5;		}	}	return GetTickCount() - start; }이 때 release 의 결과는 i = 0 일 때 172, i = 1 일 때 312, i = 2 일 때 281 이다.i 를 파라메타로 받기 때문에 컴파일러는 test 값을 미리 결정짓지 못하고 asm 코드를 작성했다.1.1 교훈 #가장 자주 나오는 경우를 if, case 의 가장 처음에 놓는다.소스가 어떤 asm 코드로 바뀌는지 확인해 준다. [코멘트] 2006-06-07 10:39 김용현 (kyh2984@hotmail.com) 어떤 예제일까요?? 답변으로 질문을 유추하기 어렵습니다. ㅠ_ㅠ최적화를 끄는거라면 #pragma optimize 로 대강 끌수는 있는데, 이건 아닌것 같고.. 추연우님의 질문이 어떤건가요? [코멘트] 2006-06-07 10:59 박일 (ParkPD) 앞에 내용 추가했습니다. ㅎㅎ [코멘트] 2006-06-07 11:08 이기탁 (snaiper) switch-case 문은 case 가 3개 이하인 경우는 박일님 말대로 처음에 놓는게 좋지만, 4개 이상인 경우에는가장 처음에 놓든 아니든 관계 없습니다. 점프 테이블로 구성되기 때문이죠. VC 강좌/팁란에서이거 때문에 조금 토론(?) 한적이 있죠 [코멘트] 2006-06-07 14:16 김용현 (kyh2984@hotmail.com) 아..~ 이제 앞에 문장이 보이는군요~ 아트오브어셈블리에서 관련 비슷한 내용을 본것 같긴한데.. 그러고 보니 switch 문을 쓰기 전에 앞도적으로 많이 쓰이는 것은 앞에 if 로 빼 놓으면 속도면에서 좋겠군요. 얼마전 태권브이님의 글중 C++ 의 새로운 키워드 else-switch 문이 생각나네요 ^^ [코멘트] 2006-06-08 00:59 추연우 (pop114) 오... 바로 테스트 코드까지..^^.. 점프 테이블로 구성된다는 것은 \"c++ Footprint and Performance Optimization\"이란 책에서 저도 봤는데 혹시연속된 case 의 경우만 적용되는 것이 아닌가요? case 0:case 1:case 2:..이런식의 경우는 점프테이블을 구성하고 각 case의 경우를 점프테이블의 인덱스로 사용한다고 알고 있고case 300:case 13:case 33:..이런식의 경우는 case 를 그룹화하는 식으로(처음 비교시 300보다 크면 13,33 은 비교할 필요가 없어서 if..else 의 else의 위치하는 식)처리한다고 알고 있었는데...제가 잘못알고 있었는지요..ㅡ_ㅜ 코멘트쓰기 * 코멘트는 500자 이내(띄어쓰기 포함)로 적어주세요. 덱스퍼트(dExpert) [C#]자동업데이트(HTTP) 풀 소스(Update Profile 생성 프로그램 포함) 15,000원 [한울소프트 VB 상용소프트웨어 풀소스 공개] 25,000원 [재고/자재/입출고]관리프로그램 9,000원 [VB] 엑셀파일 DB에 입력하는 프로그램(Mysql,MS-SQL,Oracle,엑서스) 10,000원 ActiveX를 이용하여 FTP를 통해 게임 설치 및 실행까지 전단계 코드 수록 15,000원 문서공유시스템 (소스공개) 15,000원 [VB, MS-SQL] 외부에서 원격서버 접속하여 데이타관리 프로그램. 10,000원 MFC 시리얼 통신데이터로 그래프 그리기(배팅금액 더 드립니다.) 4,000원 MFC프로그램 두개의 소스 합치기 요청(영상처리와 파일전송 프로그램) 20,000원 이소스를 MFC 6.0 다이얼로그 베이스로 변경해주세요. 그리고 조금 수정을... 30,000원 고속도로 통행요금 관리 프로그램 만들어주실분(과제용) 10,000원 이퀄라이저 소스 좀 주세요 5,000원 음식점 주문 프로그램만드는중입니다 3,000원 ftp서버로 계정관리 하기~ 3,000원 회사소개 | 개인정보취급방침 | 제휴문의 | 광고문의 | E-Mail 무단수집거부 | 고객지원 | 이용안내 | 세금계산서 파트너 사이트 마이크로소프트 (주)유앤와이즈 DEXTSolution 패밀리 사이트 DEXTSolution 자바누리 PHP스쿨 유리아 솔루션 (주)유앤와이즈 공정거래위원회 고시 제 2000-1호에 따른 사업자등록번호 안내: 220-81-90008 / 대표: 홍영준서울시 강남구 역삼동 662-18 강남텔레피아빌딩 9층 / TEL. 02_511_4824 / FAX. 02_511_4823Copyright ⓒ (주) 데브피아. All rights reserved.";
const char* TestString =
	"!*'();:@&=+$,/?%#[]";

///////////////////////////////////////////////////////////////////////////////
// Entry
void checkTime1();
void checkTime2();

///////////////////////////////////////////////////////////////////////////////

int main() {
	checkTime1();
	checkTime2();

	return 0;
}

///////////////////////////////////////////////////////////////////////////////
using namespace namo;

void checkTime1()
{
	LARGE_INTEGER t1, t2, fr, diff;
	if( ::QueryPerformanceFrequency(&fr) != 0) {	// 하드웨어가 고해상도 카운터를 지원할 때
		bool isSuccess = true;
		if( ::QueryPerformanceCounter(&t1) == 0 ) isSuccess = false;

		// perform
		std::string res(ToPercentEncoding(TestString)
			);

		if( ::QueryPerformanceCounter(&t2) == 0 ) isSuccess = false;
		if ( isSuccess ) {
			diff.QuadPart = (LONGLONG)t2.QuadPart - t1.QuadPart;
			double ㎲ = (double)diff.QuadPart / ((double)fr.QuadPart);
			fprintf(stdout, "수행시간 : %f ㎳\n", ㎲*1000);
		}
		else {
			fprintf(stderr, "수행시간 측정에 에러(%d)\n", ::GetLastError());
		}

		std::cout << res << std::endl;
	}
	else {
		fprintf(stderr, "하드웨어가 고해상도 카운터를 지원하지 않습니다.\n");
	}
}

void checkTime2()
{
	LARGE_INTEGER t1, t2, fr, diff;
	if( ::QueryPerformanceFrequency(&fr) != 0) {	// 하드웨어가 고해상도 카운터를 지원할 때
		bool isSuccess = true;
		if( ::QueryPerformanceCounter(&t1) == 0 ) isSuccess = false;

		// perform
		std::string res(URIEscape(TestString)
			);

		if( ::QueryPerformanceCounter(&t2) == 0 ) isSuccess = false;
		if ( isSuccess ) {
			diff.QuadPart = (LONGLONG)t2.QuadPart - t1.QuadPart;
			double ㎲ = (double)diff.QuadPart / ((double)fr.QuadPart);
			fprintf(stdout, "수행시간 : %f ㎳\n", ㎲*1000);
		}
		else {
			fprintf(stderr, "수행시간 측정에 에러(%d)\n", ::GetLastError());
		}

		std::cout << res << std::endl;
	}
	else {
		fprintf(stderr, "하드웨어가 고해상도 카운터를 지원하지 않습니다.\n");
	}
}